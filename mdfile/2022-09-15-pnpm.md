---
layout: post
title: pnpm yarn npm
---

### npm2

npm2的node_modules是嵌套的。多个包难免有公共的依赖，这样嵌套的话，同样的依赖会被复制很多次，会占据较大的磁盘空间。并且window的文件路径最长是260多个字符，这样嵌套是会超过最长的长度限制的。

### yarn

yarn是把所有的依赖铺平，不再是一层一层嵌套了，而是全部在同一层，这样也没有依赖重复多次的问题了，也就没有路径过长的问题了。但是也会存在有的包还是有自己的node_modules的问题，因为一个包可能有多个版本，提升到根目录只能提升一个，所以后面再遇到相同的包不同版本，依然还是用嵌套的方式。

npm3也采用了铺平的方式，和yarn的方式类似。

扁平化依赖也会有相应的问题，最主要的一个问题是幽灵依赖，也就是明明没有生命在dependencies里的依赖，但是在代码里却可以require进来。这样也容易理解，因为铺平了，依赖都是可以在项目里直接找到的。

但是这样有隐患，因为没有显式依赖，万一有一天别的包不依赖这个包了，那代码就跑不起来了，因为依赖了这个包，但是现在不会被安装了。

这就是幽灵依赖的问题。

还有一个问题，就是上面提到的依赖包有多个版本的时候，只会提升一个，那其他的版本的包不还是复制了很多次没，依然会有浪费磁盘空间的问题。

### pnpm

npm3 和 yarn之所以需要扁平化node_modules，就是因为同样的依赖会被复制多次，并且路径过长window下会有问题。如果不复制，直接link.

link就是软硬链接，这是操作系统提供的机制，硬链接就是同一个文件的不同引用，软连接是新建一个文件，文件内容指向另一个路径。当然，这俩连接用起来都是差不多的。

如果不复制文件，只在全局仓库保存一份npm包的内容呢，其他的地方都link过去呢。

这样不会有复制多次浪费空间的问题，而且也不会有路径过长的问题，因为路径过长的限制本质上不能有太深的目录层级，现在都是各个位置的目录的link,并不是同一个目录，所以也不会有长度限制。

也就是说，所有的依赖都是从全局store硬连接到了node_modules/.pnpm下，然后之间通过软连接来互相依赖。

### 总结

npm2是通过嵌套的方式管理node_modules，会有同样的依赖多次的问题

npm3+和yarn是通过铺平扁平化的方式来管理node_modules，解决了嵌套多次的问题，但是引入了幽灵依赖的问题，并且相同的包只会提升一个版本，其余的版本还是会被复制多次。

pnpm则采用了另一个方式，不再是复制，而是都从全局的store的硬连接到node_modules/.pnpm，然后之间通过软连接来组织依赖关系。

这样不但能够节省磁盘空间，也没有幽灵依赖的问题，安装速度还快，从机制上完胜npm和yarn